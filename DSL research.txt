--------------------------------------------------------------------------------
        Reprogrammable macro keyboard Domain Specific Language (DSL):
--------------------------------------------------------------------------------

Requirements:
  - Must be as compact as possible so as to
    1. Not take up very much memory on the microcontroller
    2. Easily formable on the frontend
  - Technically:
    - Must be able to use all HID characters
    - Perform presses with varying duration between each
    - Hold down one or more keys and allow others to be pressed whilst held down


Possible layouts:

_$0.5C0.5V$_

The above could potentially be parsed as holding down control, and then pressing
C, followed by V 0.5 seconds later. In this set up, lifting and pressing of
the control key are two separate actions, and all numerical values correspond to
time delays. This isn't ideal, as it means you can't use numbers as macros.

Delays could be preceded by a special character, or could be hardcoded time delays
of 0.5 seconds or shorter, which are then represented in a similar manner to how
the CTRL character is being represented above. This would give:

_$_t0.5C_t0.5V$_

Where _t denotes a delay, and 0.5 is the duration. There is still an issue where
numerical characters coming after this will be treated as part of a delay. An
alternative to this could be closing characters as seen with the CTRL key

_$_t0.5t_C_t0.5t_V$_

With this method, the underscores serve as separators for each command (mostly)
so gives a fairly human readable representation of the macro.

--------------------------------------------------------------------------------
                            Implementation notes:
--------------------------------------------------------------------------------

The easiest way to process commands (i.e individual key commands) would be through
the use of C structs, holding the key code required to be pressed, and the command
type. This could work in a few ways, one would be to use key-command actions and 
dispatch HID events based off of this. This would work as such:

Example 1: Shift modifier down action 
--------------------------------------

KeyAction {
  Type:"MODIFIER_DOWN",
  Payload:KEY_SHIFT
}


Example 2: Single key press
--------------------------------------

KeyAction {
  Type:"SINGLE_PRESS",
  Payload:'A'
}


Example 3: String printing
--------------------------------------

KeyAction {
  Type:"RAW_STRING",
  Payload:"This is an example String \n"
}

In these examples, the action types could be easily enumerated, and when storing to keyboard-
local storage could be formatted such that it's programatically easy to interpret. In these examples
it's notable that the payload is of different type in each example, requiring the use of templates.

This would mean each macro is implemented as an array of actions, which would be loaded from 
keyboard-local storage on startup. The firmware would need to be able to interpret command 
overwriting strings sent via Serial, and rewrite the config saved locally on the keyboard.

To minimise runtime computation required, each string sent to the device via Serial, and saved
to storage would be written in the same format. This allows direct modification of the config
as new overwriting Strings are sent through, and then partial, or total refresh of the device.
Note, total refresh i.e re-running the routine to generate the Action Vectors in memory would 
be useful in the case where the user updates all the macros from the supporting software, 
requiring the entire config to be changed.